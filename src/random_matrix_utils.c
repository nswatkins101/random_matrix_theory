#include<stdio.h>
#include<math.h>

#include<gsl/gsl_eigen.h>
#include<gsl/gsl_complex.h>

#include<graph_alloc_utils.h>
#include<matrix_utils.h>
#include<opt_utils.h>
#include<extern_var.h>
#include<random_matrix_utils.h>

void normalized_ER_RG(gsl_matrix* a_mat, double p)
{
	ER_RG_inplace(a_mat, p);
	/* shift and scale so that mean is 0 and variance is 1 */
	gsl_matrix_add_constant(a_mat, -p);
	gsl_matrix_scale(a_mat, 1.0/sqrt(a_mat->size1*p*(1.0-p)));
}

void normalized_ER_RDG(gsl_matrix* a_mat, double p)
{
	ER_RDG_inplace(a_mat, p);
	/* shift and scale so that mean is 0 and variance is 1 */
	gsl_matrix_add_constant(a_mat, -p);
	gsl_matrix_scale(a_mat, 1.0/sqrt(a_mat->size1*p*(1.0-p)));
}

/* wraps generators and operators */
void gen_ER_RG(void** args)
{
	gsl_matrix* a_mat = (gsl_matrix*)args[0];
	double p = *(double*)args[1];
	ER_RG_inplace(a_mat, p);
}

void gen_ER_RDG(void** args)
{
	gsl_matrix* a_mat = (gsl_matrix*)args[0];
	double p = *(double*)args[1];
	ER_RDG_inplace(a_mat, p);
}	

void gen_normalized_ER_RG(void** args)
{
	gsl_matrix* a_mat = (gsl_matrix*)args[0];
	double p = *(double*)args[1];
	normalized_ER_RG(a_mat, p);
}

void gen_normalized_ER_RDG(void** args)
{
	gsl_matrix* a_mat = (gsl_matrix*)args[0];
	double p = *(double*)args[1];
	normalized_ER_RDG(a_mat, p);
}	

void gen_L_NL(void** args)
{
	gsl_matrix* mat = (gsl_matrix*)args[0];
	int coord = *(int*)args[1];
	double delta = *(double*)args[2];
	double a = *(double*)args[3];
	gsl_matrix* temp_mat = get_extern_temp_mat();
	
	bethe_lattice(temp_mat, coord);
	ER_RG_inplace(mat, delta);
	gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, a, temp_mat, identity_mat, (1.0-a), mat);	
	reset_extern_temp_mat(temp_mat);
}

double op_kemeny(void** args)
{
	gsl_matrix* mat = (gsl_matrix*)args[0];
	return gsl_matrix_kemeny(mat);
}

int random_matrix_esd(FILE* stream, int len_esd, double* esd, int num_samples, void (*generator)(void**), void** args, int symm)
{
	// infer span and dx from esd
	double span[2];
	span[0] = esd[0];
	span[1] = esd[2*(len_esd-1)];
	double dx = esd[2]-esd[0];
	
	gsl_matrix* mat = (gsl_matrix*)args[0];
	gsl_vector_view eval_view;
	gsl_vector* temp_vec = get_extern_temp_vec();
	gsl_vector_complex* temp_cvec = get_extern_temp_cvec();
	double eval = 0;
	int pos = 0;
	/* loop where I generate random matrices and calculate their eigenvalues */
	for(int i=0; i<num_samples; i++)
	{
		(*generator)(args);
		
		printf("writing matrix...");
		gsl_matrix_fprintf_delim(stream, mat, ", ");
		printf("finished.\n");
		
		printf("calculating spectrum...");
		// if symm, calculate the spectrum with gsl_eigen_symm, and return any error codes
		if(symm)
			printf("%s.\n", gsl_strerror(gsl_eigen_symm(mat, temp_vec, g_w_symm)));
		// if not symm, calculate the spectrum with gsl_eigen_nonsymm, and return any error codes
		else
			printf("%s.\n", gsl_strerror(gsl_eigen_nonsymm(mat, temp_cvec, g_w_nonsymm)));
		if(!symm)
			eval_view = gsl_vector_complex_real(temp_cvec);
		for(int j=0; j<temp_vec->size; j++)
		{
			if(symm)
				eval = temp_vec->data[j];
			else
				eval = eval_view.vector.data[j];
			pos = (int)((eval-span[0])/dx);
			if(pos < len_esd && pos >= 0)
				esd[2*pos+1] += 1;
		}
	}
	/* normalize the empirical spectral distribution */
	double normalization = 0;
	for(int i=0; i<len_esd; i++)
		normalization += esd[2*i+1]*dx;
	for(int i=0; i<len_esd; i++)
		esd[2*i+1] = esd[2*i+1]/normalization;

	/* reset extern global variables */
	reset_extern_temp_vec(temp_vec);
	reset_extern_temp_cvec(temp_cvec);
	return 0;
}

/* calculates the expectation of the output of operator by averaging over samples from
 * the matrix ensemble, with each member generated by generator. Only works for
 * symmetric matrices. NOTE: the functions are not type-safe. Requires that the op_args 
 * be somehow related to the gen_args, i.e. gen_args = gsl_matrix*, modifies gsl_matrix*,
 * then op_args = the same ptr, calculates and return the value based on that gsl_matrix*
 */
double random_matrix_expectation(int samples, double (*operator)(void**), void** op_args, void (*generator)(void**), void** gen_args)
{
	double total = 0;
	for(int i=0; i<samples; i++)
	{
		(*generator)(gen_args);
		total += (*operator)(op_args);
	}
	double expectation  = total/samples;
	return expectation;
}

	
	

